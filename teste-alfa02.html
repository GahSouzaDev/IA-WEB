<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Detector IA REAL - Placas Eletr√¥nicas</title>
    
    <!-- TensorFlow.js vers√£o espec√≠fica e est√°vel -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .main-content {
            padding: 30px;
        }

        .section {
            margin-bottom: 30px;
            padding: 25px;
            border: 2px solid #ecf0f1;
            border-radius: 10px;
            background: #fafafa;
        }

        .section h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.8em;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        label {
            font-weight: bold;
            color: #2c3e50;
            font-size: 1.1em;
        }

        select, input, button {
            padding: 12px;
            border: 2px solid #bdc3c7;
            border-radius: 8px;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        select:focus, input:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.3);
        }

        button {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.4);
        }

        button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .camera-section {
            text-align: center;
        }

        #videoElement, #realtimeVideo {
            width: 400px;
            height: 400px;
            border: 3px solid #3498db;
            border-radius: 10px;
            object-fit: cover;
            margin: 20px auto;
            display: block;
        }

        .realtime-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            align-items: start;
        }

        .realtime-video {
            text-align: center;
            position: relative;
        }

        .realtime-results {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #dee2e6;
        }

        .realtime-prediction {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            text-align: center;
            font-size: 1.5em;
            font-weight: bold;
            border: 3px solid #ecf0f1;
            transition: all 0.3s ease;
        }

        .prediction-correct-realtime {
            background: #d5f4e6;
            color: #27ae60;
            border-color: #27ae60;
            box-shadow: 0 0 20px rgba(39, 174, 96, 0.3);
        }

        .prediction-incorrect-realtime {
            background: #fadbd8;
            color: #e74c3c;
            border-color: #e74c3c;
            box-shadow: 0 0 20px rgba(231, 76, 60, 0.3);
        }

        .confidence-bar {
            width: 100%;
            height: 30px;
            background: #ecf0f1;
            border-radius: 15px;
            overflow: hidden;
            margin: 15px 0;
        }

        .confidence-fill {
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .confidence-correct {
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
        }

        .confidence-incorrect {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .stat-label {
            font-size: 0.9em;
            color: #7f8c8d;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #2c3e50;
        }

        .capture-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .label-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 15px 0;
        }

        .btn-success {
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        .btn-warning {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        }

        .btn-realtime {
            background: linear-gradient(135deg, #8e44ad 0%, #9b59b6 100%);
            font-size: 1.2em;
            padding: 15px 30px;
        }

        .btn-realtime.active {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(231, 76, 60, 0); }
            100% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0); }
        }

        .image-counter {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            margin: 20px 0;
        }

        .counter-item {
            display: inline-block;
            margin: 0 20px;
            padding: 10px 20px;
            background: white;
            border-radius: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .counter-correct {
            border-left: 5px solid #27ae60;
        }

        .counter-incorrect {
            border-left: 5px solid #e74c3c;
        }

        #logArea {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.4;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 5px;
            border-radius: 3px;
        }

        .log-info { color: #3498db; }
        .log-success { color: #27ae60; }
        .log-error { color: #e74c3c; }
        .log-warning { color: #f39c12; }

        .warning-box {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .error-box {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .training-progress {
            background: #e8f5e8;
            border: 1px solid #27ae60;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #ecf0f1;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .training-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }

        .stat-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .fps-counter {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 0.9em;
        }

        .instructions {
            background: #e8f4f8;
            padding: 20px;
            border-radius: 10px;
            border-left: 5px solid #3498db;
            margin-bottom: 30px;
        }

        .instructions h3 {
            color: #2c3e50;
            margin-bottom: 15px;
        }

        .instructions ol {
            padding-left: 20px;
        }

        .instructions li {
            margin-bottom: 8px;
            line-height: 1.5;
        }

        .prediction-result {
            background: #ecf0f1;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            margin-top: 20px;
            font-size: 1.3em;
            font-weight: bold;
        }

        .prediction-correct {
            background: #d5f4e6;
            color: #27ae60;
            border: 2px solid #27ae60;
        }

        .prediction-incorrect {
            background: #fadbd8;
            color: #e74c3c;
            border: 2px solid #e74c3c;
        }

        .model-info {
            background: #e3f2fd;
            border: 1px solid #2196f3;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        /* Responsividade */
        @media (max-width: 768px) {
            .controls-grid, .realtime-section {
                grid-template-columns: 1fr;
            }
            
            .capture-controls {
                flex-direction: column;
                align-items: center;
            }
            
            #videoElement, #realtimeVideo {
                width: 300px;
                height: 300px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .main-content {
                padding: 20px;
            }

            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* Canvas oculto */
        #captureCanvas, #realtimeCanvas {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîß DETECTOR IA REAL - Placas Eletr√¥nicas</h1>
            <p>Intelig√™ncia Artificial VERDADEIRA com CNN Avan√ßada - An√°lise Visual Real</p>
        </div>

        <div class="main-content">
            <!-- Instru√ß√µes -->
            <div class="instructions">
                <h3>üìã DETECTOR IA REAL - Como usar:</h3>
                <ol>
                    <li><strong>IMPORTANTE:</strong> Use objetos/placas REALMENTE diferentes visualmente</li>
                    <li><strong>Capture pelo menos 15 imagens por classe</strong> com boa ilumina√ß√£o e √¢ngulos variados</li>
                    <li><strong>Certifique-se</strong> que as imagens "certas" e "erradas" tenham diferen√ßas visuais claras</li>
                    <li><strong>O modelo CNN</strong> analisar√° bordas, texturas, formas e padr√µes reais</li>
                    <li><strong>Treine com 15+ √©pocas</strong> para aprendizado profundo</li>
                    <li><strong>Teste em tempo real</strong> com objetos similares aos do treinamento</li>
                </ol>
            </div>

            <!-- Status do Sistema -->
            <div class="section">
                <h2>üîß Status do Sistema IA</h2>
                <div id="systemStatus"></div>
                <div id="modelInfo" class="model-info" style="display: none;"></div>
            </div>

            <!-- Configura√ß√µes -->
            <div class="section">
                <h2>‚öôÔ∏è Configura√ß√µes IA Avan√ßada</h2>
                <div class="controls-grid">
                    <div class="control-group">
                        <label for="hardwareSelect">Hardware:</label>
                        <select id="hardwareSelect">
                            <option value="cpu">CPU (Est√°vel)</option>
                            <option value="webgl">GPU (WebGL)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="epochsInput">√âpocas (Aprendizado Profundo):</label>
                        <input type="number" id="epochsInput" min="5" max="50" value="15">
                    </div>
                    <div class="control-group">
                        <label for="minImagesInput">M√≠nimo por Classe:</label>
                        <input type="number" id="minImagesInput" min="10" max="100" value="15">
                    </div>
                </div>
            </div>

            <!-- Captura de Imagens -->
            <div class="section">
                <h2>üì∑ Captura de Imagens para IA</h2>
                <div class="camera-section">
                    <video id="videoElement" autoplay muted playsinline></video>
                    <canvas id="captureCanvas" width="224" height="224"></canvas>
                    
                    <div class="capture-controls">
                        <button id="startCameraBtn" class="btn-success">üìπ Ligar C√¢mera</button>
                        <button id="stopCameraBtn" class="btn-danger" disabled>‚èπÔ∏è Desligar C√¢mera</button>
                        <button id="captureBtn" class="btn-warning" disabled>üì∏ Capturar Foto</button>
                    </div>

                    <div class="label-buttons" id="labelButtons" style="display: none;">
                        <button id="labelCorrectBtn" class="btn-success">‚úÖ CERTO (Sem Defeitos)</button>
                        <button id="labelIncorrectBtn" class="btn-danger">‚ùå ERRADO (Com Defeitos)</button>
                    </div>

                    <div class="control-group" style="margin-top: 20px;">
                        <label for="fileInput">Ou carregue imagens:</label>
                        <input type="file" id="fileInput" accept="image/*" multiple>
                    </div>
                </div>

                <div class="image-counter">
                    <div class="counter-item counter-correct">
                        <span>‚úÖ Corretas: </span>
                        <span id="correctCount">0</span>
                    </div>
                    <div class="counter-item counter-incorrect">
                        <span>‚ùå Incorretas: </span>
                        <span id="incorrectCount">0</span>
                    </div>
                </div>
            </div>

            <!-- Treinamento -->
            <div class="section">
                <h2>üß† Treinamento IA Avan√ßado</h2>
                <div style="text-align: center;">
                    <button id="trainBtn" class="btn-warning" disabled>üöÄ TREINAR IA REAL</button>
                    <button id="saveModelBtn" class="btn-success" disabled style="margin-left: 10px;">üíæ Salvar IA</button>
                    <button id="loadModelBtn" class="btn-warning" style="margin-left: 10px;">üìÇ Carregar IA</button>
                    <button id="resetBtn" class="btn-danger" style="margin-left: 10px;">üîÑ Reset</button>
                </div>
                
                <div id="trainingProgress" style="display: none;"></div>
            </div>

            <!-- Detec√ß√£o em Tempo Real -->
            <div class="section">
                <h2>üéØ DETEC√á√ÉO IA EM TEMPO REAL</h2>
                <div style="text-align: center; margin-bottom: 20px;">
                    <button id="realtimeBtn" class="btn-realtime" disabled>üî¥ INICIAR IA TEMPO REAL</button>
                </div>
                
                <div class="realtime-section" id="realtimeSection" style="display: none;">
                    <div class="realtime-video">
                        <video id="realtimeVideo" autoplay muted playsinline></video>
                        <div class="fps-counter" id="fpsCounter">FPS: 0</div>
                        <canvas id="realtimeCanvas" width="224" height="224"></canvas>
                    </div>
                    
                    <div class="realtime-results">
                        <h3>üìä An√°lise IA em Tempo Real</h3>
                        
                        <div class="realtime-prediction" id="realtimePrediction">
                            Aguardando an√°lise IA...
                        </div>
                        
                        <div class="confidence-bar">
                            <div class="confidence-fill" id="confidenceFill" style="width: 0%;">
                                0%
                            </div>
                        </div>
                        
                        <div class="stats-grid">
                            <div class="stat-card">
                                <div class="stat-label">Total Analisadas</div>
                                <div class="stat-value" id="totalAnalyzed">0</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-label">Corretas</div>
                                <div class="stat-value" id="correctDetected">0</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-label">Incorretas</div>
                                <div class="stat-value" id="incorrectDetected">0</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-label">Confian√ßa IA</div>
                                <div class="stat-value" id="avgConfidence">0%</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Teste Manual -->
            <div class="section">
                <h2>üîç Teste Manual IA</h2>
                <div style="text-align: center;">
                    <button id="testCaptureBtn" class="btn-warning" disabled>üì∏ Capturar Teste IA</button>
                    <input type="file" id="testFileInput" accept="image/*" style="margin: 10px;">
                    <button id="testFileBtn" class="btn-warning" disabled>üìÅ Testar Arquivo IA</button>
                </div>
                <div id="predictionResult"></div>
            </div>

            <!-- Log -->
            <div class="section">
                <h2>üìù Log IA</h2>
                <div id="logArea"></div>
            </div>
        </div>
    </div>

    <script>
        // Aguardar carregamento completo
        window.addEventListener('load', function() {
            setTimeout(initializeApp, 1000); // Delay para garantir carregamento do TF
        });

        // ==================== VARI√ÅVEIS GLOBAIS ====================
        let videoElement, captureCanvas, captureContext;
        let realtimeVideo, realtimeCanvas, realtimeContext;
        let stream = null, realtimeStream = null;
        let model = null;
        let isModelTrained = false;
        let currentBackend = 'cpu';
        let isTraining = false;
        let isRealtimeActive = false;
        let realtimeInterval = null;
        let fpsInterval = null;
        
        // Arrays para dados
        let correctImages = [];
        let incorrectImages = [];
        let capturedImageData = null;

        // Estat√≠sticas
        let realtimeStats = {
            totalAnalyzed: 0,
            correctDetected: 0,
            incorrectDetected: 0,
            confidenceSum: 0,
            frameCount: 0
        };

        // Configura√ß√µes IA REAL
        const IMAGE_SIZE = 224;
        const DEFAULT_MIN_IMAGES = 15;

        // ==================== INICIALIZA√á√ÉO ====================
        async function initializeApp() {
            try {
                logMessage('üöÄ Iniciando sistema IA...', 'info');
                
                videoElement = document.getElementById('videoElement');
                captureCanvas = document.getElementById('captureCanvas');
                captureContext = captureCanvas.getContext('2d');
                
                realtimeVideo = document.getElementById('realtimeVideo');
                realtimeCanvas = document.getElementById('realtimeCanvas');
                realtimeContext = realtimeCanvas.getContext('2d');
                
                await initializeTensorFlow();
                setupEventListeners();
                
                logMessage('üöÄ SISTEMA IA REAL INICIADO! Pronto para an√°lise visual avan√ßada.', 'success');
            } catch (error) {
                logMessage('‚ùå Erro na inicializa√ß√£o: ' + error.message, 'error');
            }
        }

        async function initializeTensorFlow() {
            try {
                if (typeof tf === 'undefined') {
                    throw new Error('TensorFlow.js n√£o carregado');
                }
                
                logMessage('‚è≥ Aguardando TensorFlow.js...', 'info');
                await tf.ready();
                logMessage('üß† TensorFlow.js carregado! IA pronta.', 'success');
                
                // For√ßar CPU para estabilidade
                await tf.setBackend('cpu');
                await tf.ready();
                currentBackend = 'cpu';
                logMessage('üîß CPU configurada para m√°xima estabilidade', 'success');
                
                updateSystemStatus();
                
            } catch (error) {
                logMessage('‚ùå Erro TensorFlow: ' + error.message, 'error');
                showErrorBox('Erro ao carregar TensorFlow.js');
            }
        }

        function updateSystemStatus() {
            const statusDiv = document.getElementById('systemStatus');
            const backend = tf.getBackend();
            const memory = tf.memory();
            
            statusDiv.innerHTML = `
                <div class="warning-box">
                    <strong>üîß Status IA:</strong><br>
                    ‚Ä¢ Backend: <strong>${backend.toUpperCase()}</strong><br>
                    ‚Ä¢ Tensores Ativos: <strong>${memory.numTensors}</strong><br>
                    ‚Ä¢ Resolu√ß√£o IA: <strong>${IMAGE_SIZE}x${IMAGE_SIZE}</strong><br>
                    ‚Ä¢ Modelo: <strong>${isModelTrained ? '‚úÖ TREINADO' : '‚ùå N√ÉO TREINADO'}</strong><br>
                    ‚Ä¢ Tempo Real: <strong>${isRealtimeActive ? 'üî¥ ATIVO' : '‚ö´ Inativo'}</strong><br>
                    ‚Ä¢ Tipo: <strong>CNN Avan√ßada (An√°lise Visual Real)</strong>
                </div>
            `;
        }

        function setupEventListeners() {
            document.getElementById('startCameraBtn').addEventListener('click', startCamera);
            document.getElementById('stopCameraBtn').addEventListener('click', stopCamera);
            document.getElementById('captureBtn').addEventListener('click', capturePhoto);
            
            document.getElementById('labelCorrectBtn').addEventListener('click', function() { labelImage('correct'); });
            document.getElementById('labelIncorrectBtn').addEventListener('click', function() { labelImage('incorrect'); });
            
            document.getElementById('fileInput').addEventListener('change', handleFileUpload);
            
            document.getElementById('trainBtn').addEventListener('click', trainModel);
            document.getElementById('saveModelBtn').addEventListener('click', saveModel);
            document.getElementById('loadModelBtn').addEventListener('click', loadModel);
            document.getElementById('resetBtn').addEventListener('click', resetData);
            
            document.getElementById('realtimeBtn').addEventListener('click', toggleRealtime);
            
            document.getElementById('testCaptureBtn').addEventListener('click', captureForTest);
            document.getElementById('testFileBtn').addEventListener('click', testWithFile);
            document.getElementById('testFileInput').addEventListener('change', handleTestFileUpload);
            
            document.getElementById('hardwareSelect').addEventListener('change', handleBackendChange);
            document.getElementById('minImagesInput').addEventListener('change', updateImageCounter);
            
            updateImageCounter();
        }

        async function handleBackendChange() {
            if (isTraining || isRealtimeActive) {
                logMessage('‚ùå N√£o √© poss√≠vel mudar backend durante opera√ß√µes ativas', 'warning');
                return;
            }
            
            const selectedBackend = document.getElementById('hardwareSelect').value;
            
            try {
                await tf.setBackend(selectedBackend);
                await tf.ready();
                currentBackend = selectedBackend;
                logMessage('‚úÖ Backend alterado: ' + selectedBackend.toUpperCase(), 'success');
                updateSystemStatus();
            } catch (error) {
                logMessage('‚ùå Erro backend: ' + error.message, 'error');
                await tf.setBackend('cpu');
                currentBackend = 'cpu';
                document.getElementById('hardwareSelect').value = 'cpu';
            }
        }

        // ==================== C√ÇMERA ====================
        async function startCamera() {
            try {
                logMessage('üìπ Acessando c√¢mera...', 'info');
                
                stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        width: { ideal: 1280 }, 
                        height: { ideal: 720 }, 
                        facingMode: 'environment' 
                    }
                });
                videoElement.srcObject = stream;
                
                document.getElementById('startCameraBtn').disabled = true;
                document.getElementById('stopCameraBtn').disabled = false;
                document.getElementById('captureBtn').disabled = false;
                
                logMessage('‚úÖ C√¢mera ativa! Pronta para captura IA.', 'success');
            } catch (error) {
                logMessage('‚ùå Erro c√¢mera: ' + error.message, 'error');
            }
        }

        function stopCamera() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
                videoElement.srcObject = null;
                
                document.getElementById('startCameraBtn').disabled = false;
                document.getElementById('stopCameraBtn').disabled = true;
                document.getElementById('captureBtn').disabled = true;
                document.getElementById('labelButtons').style.display = 'none';
                
                logMessage('üìπ C√¢mera desligada', 'info');
            }
        }

        function capturePhoto() {
            try {
                captureContext.drawImage(videoElement, 0, 0, IMAGE_SIZE, IMAGE_SIZE);
                capturedImageData = captureContext.getImageData(0, 0, IMAGE_SIZE, IMAGE_SIZE);
                
                document.getElementById('labelButtons').style.display = 'flex';
                logMessage('üì∏ Foto capturada! Escolha o r√≥tulo para IA.', 'success');
            } catch (error) {
                logMessage('‚ùå Erro captura: ' + error.message, 'error');
            }
        }

        function labelImage(label) {
            if (!capturedImageData) {
                logMessage('‚ùå Nenhuma imagem para rotular', 'error');
                return;
            }
            
            try {
                const tensor = preprocessImageData(capturedImageData);
                
                if (label === 'correct') {
                    correctImages.push(tensor);
                    logMessage('‚úÖ Imagem "CERTO" adicionada ao dataset IA', 'success');
                } else {
                    incorrectImages.push(tensor);
                    logMessage('‚ùå Imagem "ERRADO" adicionada ao dataset IA', 'success');
                }
                
                updateImageCounter();
                checkTrainingReadiness();
                
                document.getElementById('labelButtons').style.display = 'none';
                capturedImageData = null;
                
            } catch (error) {
                logMessage('‚ùå Erro processamento: ' + error.message, 'error');
            }
        }

        function handleFileUpload(event) {
            const files = event.target.files;
            if (files.length === 0) return;
            
            logMessage('üìÅ Processando ' + files.length + ' arquivo(s) para IA...', 'info');
            
            Array.from(files).forEach(function(file, index) {
                processUploadedFile(file, index + 1, files.length);
            });
        }

        function processUploadedFile(file, current, total) {
            const reader = new FileReader();
            
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    try {
                        const canvas = document.createElement('canvas');
                        canvas.width = IMAGE_SIZE;
                        canvas.height = IMAGE_SIZE;
                        const ctx = canvas.getContext('2d');
                        
                        ctx.drawImage(img, 0, 0, IMAGE_SIZE, IMAGE_SIZE);
                        const imageData = ctx.getImageData(0, 0, IMAGE_SIZE, IMAGE_SIZE);
                        const tensor = preprocessImageData(imageData);
                        
                        correctImages.push(tensor);
                        
                        logMessage('üìÅ Arquivo ' + current + '/' + total + ' processado para IA', 'success');
                        
                        if (current === total) {
                            updateImageCounter();
                            checkTrainingReadiness();
                            logMessage('‚úÖ Todos arquivos processados! Reorganize os r√≥tulos se necess√°rio.', 'success');
                        }
                        
                    } catch (error) {
                        logMessage('‚ùå Erro arquivo ' + current + ': ' + error.message, 'error');
                    }
                };
                img.src = e.target.result;
            };
            
            reader.readAsDataURL(file);
        }

        function preprocessImageData(imageData) {
            let tensor = tf.browser.fromPixels(imageData, 3)
                .resizeNearestNeighbor([IMAGE_SIZE, IMAGE_SIZE])
                .toFloat()
                .div(255.0);
            
            return tensor;
        }

        function updateImageCounter() {
            const minImages = parseInt(document.getElementById('minImagesInput').value);
            document.getElementById('correctCount').textContent = correctImages.length;
            document.getElementById('incorrectCount').textContent = incorrectImages.length;
            
            const correctCounter = document.querySelector('.counter-correct');
            const incorrectCounter = document.querySelector('.counter-incorrect');
            
            correctCounter.style.opacity = correctImages.length >= minImages ? '1' : '0.6';
            incorrectCounter.style.opacity = incorrectImages.length >= minImages ? '1' : '0.6';
        }

        function checkTrainingReadiness() {
            const minImages = parseInt(document.getElementById('minImagesInput').value);
            const totalCorrect = correctImages.length;
            const totalIncorrect = incorrectImages.length;
            
            if (totalCorrect >= minImages && totalIncorrect >= minImages) {
                document.getElementById('trainBtn').disabled = false;
                logMessage('üöÄ PRONTO PARA IA! (' + totalCorrect + ' corretas, ' + totalIncorrect + ' incorretas)', 'success');
            } else {
                const needCorrect = Math.max(0, minImages - totalCorrect);
                const needIncorrect = Math.max(0, minImages - totalIncorrect);
                
                if (needCorrect > 0 || needIncorrect > 0) {
                    logMessage('‚ö†Ô∏è Faltam para IA: ' + needCorrect + ' corretas, ' + needIncorrect + ' incorretas', 'warning');
                }
            }
        }

        // ==================== MODELO CNN SIMPLIFICADO E EST√ÅVEL ====================
        function createStableCNNModel() {
            try {
                logMessage('üß† Criando CNN est√°vel para an√°lise visual real...', 'info');
                
                const model = tf.sequential();
                
                // Primeira camada convolucional
                model.add(tf.layers.conv2d({
                    inputShape: [IMAGE_SIZE, IMAGE_SIZE, 3],
                    filters: 32,
                    kernelSize: 3,
                    activation: 'relu',
                    padding: 'same'
                }));
                model.add(tf.layers.maxPooling2d({ poolSize: 2 }));
                
                // Segunda camada convolucional
                model.add(tf.layers.conv2d({
                    filters: 64,
                    kernelSize: 3,
                    activation: 'relu',
                    padding: 'same'
                }));
                model.add(tf.layers.maxPooling2d({ poolSize: 2 }));
                
                // Terceira camada convolucional
                model.add(tf.layers.conv2d({
                    filters: 128,
                    kernelSize: 3,
                    activation: 'relu',
                    padding: 'same'
                }));
                model.add(tf.layers.maxPooling2d({ poolSize: 2 }));
                
                // Flatten e camadas densas
                model.add(tf.layers.flatten());
                model.add(tf.layers.dense({
                    units: 128,
                    activation: 'relu'
                }));
                model.add(tf.layers.dropout({ rate: 0.5 }));
                model.add(tf.layers.dense({
                    units: 2,
                    activation: 'softmax'
                }));
                
                model.compile({
                    optimizer: tf.train.adam(0.001),
                    loss: 'categoricalCrossentropy',
                    metrics: ['accuracy']
                });
                
                updateModelInfo(model);
                
                logMessage('‚úÖ CNN est√°vel criada! Pronta para aprendizado visual.', 'success');
                return model;
                
            } catch (error) {
                logMessage('‚ùå Erro cria√ß√£o CNN: ' + error.message, 'error');
                throw error;
            }
        }

        function updateModelInfo(model) {
            const modelInfoDiv = document.getElementById('modelInfo');
            const totalParams = model.countParams();
            const layers = model.layers.length;
            
            modelInfoDiv.style.display = 'block';
            modelInfoDiv.innerHTML = `
                <strong>üß† Informa√ß√µes da CNN:</strong><br>
                ‚Ä¢ Camadas: <strong>${layers}</strong><br>
                ‚Ä¢ Par√¢metros: <strong>${totalParams.toLocaleString()}</strong><br>
                ‚Ä¢ Tipo: <strong>Convolutional Neural Network</strong><br>
                ‚Ä¢ Capacidade: <strong>An√°lise Visual Avan√ßada</strong>
            `;
        }

        function showTrainingProgress(epoch, totalEpochs, accuracy, loss, valAccuracy) {
            const progressDiv = document.getElementById('trainingProgress');
            const progress = (epoch / totalEpochs) * 100;
            
            progressDiv.style.display = 'block';
            progressDiv.innerHTML = `
                <div class="training-progress">
                    <h3>üß† IA Aprendendo... (CNN Profunda)</h3>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${progress}%"></div>
                    </div>
                    <div class="training-stats">
                        <div class="stat-item">
                            <div class="stat-label">√âpoca IA</div>
                            <div class="stat-value">${epoch}/${totalEpochs}</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Acur√°cia Treino</div>
                            <div class="stat-value">${(accuracy * 100).toFixed(1)}%</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Acur√°cia Valida√ß√£o</div>
                            <div class="stat-value">${valAccuracy ? (valAccuracy * 100).toFixed(1) : 'N/A'}%</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Perda</div>
                            <div class="stat-value">${loss.toFixed(4)}</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Progresso</div>
                            <div class="stat-value">${progress.toFixed(0)}%</div>
                        </div>
                    </div>
                </div>
            `;
        }

        function hideTrainingProgress() {
            document.getElementById('trainingProgress').style.display = 'none';
        }

        // ==================== TREINAMENTO EST√ÅVEL ====================
        async function trainModel() {
            if (isTraining) {
                logMessage('‚ö†Ô∏è IA j√° est√° treinando!', 'warning');
                return;
            }
            
            try {
                isTraining = true;
                document.getElementById('trainBtn').disabled = true;
                
                const epochs = parseInt(document.getElementById('epochsInput').value);
                logMessage('üöÄ INICIANDO TREINAMENTO IA EST√ÅVEL (' + epochs + ' √©pocas)...', 'info');
                logMessage('üß† CNN analisar√° bordas, texturas, formas e padr√µes visuais reais', 'info');
                
                if (model) {
                    model.dispose();
                    model = null;
                }
                
                const trainingData = prepareStableTrainingData();
                const xs = trainingData.xs;
                const ys = trainingData.ys;
                logMessage('üìä Dataset IA preparado: ' + xs.shape[0] + ' imagens', 'info');
                
                model = createStableCNNModel();
                logMessage('‚úÖ CNN est√°vel criada! Iniciando aprendizado profundo...', 'success');
                
                const callbacks = {
                    onEpochEnd: function(epoch, logs) {
                        const acc = logs.acc || logs.accuracy || 0;
                        const loss = logs.loss || 0;
                        const valAcc = logs.val_acc || logs.val_accuracy || 0;
                        
                        logMessage('üß† √âpoca ' + (epoch + 1) + '/' + epochs + ' - Acc: ' + (acc * 100).toFixed(1) + '% | Val: ' + (valAcc * 100).toFixed(1) + '%', 'info');
                        
                        showTrainingProgress(epoch + 1, epochs, acc, loss, valAcc);
                        updateSystemStatus();
                    }
                };
                
                await model.fit(xs, ys, {
                    epochs: epochs,
                    batchSize: 8,
                    validationSplit: 0.2,
                    shuffle: true,
                    callbacks: callbacks
                });
                
                xs.dispose();
                ys.dispose();
                
                isModelTrained = true;
                document.getElementById('saveModelBtn').disabled = false;
                document.getElementById('testCaptureBtn').disabled = false;
                document.getElementById('testFileBtn').disabled = false;
                document.getElementById('realtimeBtn').disabled = false;
                
                hideTrainingProgress();
                logMessage('üéâ TREINAMENTO IA CONCLU√çDO! CNN pronta para an√°lise visual real!', 'success');
                logMessage('üöÄ Detec√ß√£o em tempo real agora dispon√≠vel!', 'info');
                
            } catch (error) {
                logMessage('‚ùå ERRO TREINAMENTO IA: ' + error.message, 'error');
                console.error('Erro detalhado:', error);
                hideTrainingProgress();
            } finally {
                isTraining = false;
                document.getElementById('trainBtn').disabled = false;
                updateSystemStatus();
            }
        }

        function prepareStableTrainingData() {
            try {
                logMessage('üìä Preparando dataset IA est√°vel...', 'info');
                
                let allImages = [];
                let allLabels = [];
                
                // Adicionar imagens originais
                correctImages.forEach(img => {
                    allImages.push(img);
                    allLabels.push([1, 0]);
                });
                
                incorrectImages.forEach(img => {
                    allImages.push(img);
                    allLabels.push([0, 1]);
                });
                
                // Data augmentation simples e est√°vel
                const augmentedImages = [];
                const augmentedLabels = [];
                
                for (let i = 0; i < allImages.length; i++) {
                    const img = allImages[i];
                    const label = allLabels[i];
                    
                    // Imagem original
                    augmentedImages.push(img);
                    augmentedLabels.push(label);
                    
                                        // Vers√£o com brilho aumentado
                    const brightened = img.add(tf.scalar(0.1)).clipByValue(0, 1);
                    augmentedImages.push(brightened);
                    augmentedLabels.push(label);
                    
                    // Vers√£o escurecida
                    const darkened = img.mul(tf.scalar(0.8)).clipByValue(0, 1);
                    augmentedImages.push(darkened);
                    augmentedLabels.push(label);
                }
                
                if (augmentedImages.length === 0) {
                    throw new Error('Nenhuma imagem dispon√≠vel para treinamento');
                }
                
                const xs = tf.stack(augmentedImages);
                const ys = tf.tensor2d(augmentedLabels);
                
                logMessage('‚úÖ Dataset expandido: ' + augmentedImages.length + ' imagens (com augmentation est√°vel)', 'success');
                
                return { xs, ys };
            } catch (error) {
                logMessage('‚ùå Erro prepara√ß√£o dados: ' + error.message, 'error');
                throw error;
            }
        }

        // ==================== TEMPO REAL ====================
        async function toggleRealtime() {
            if (!isModelTrained) {
                logMessage('‚ùå IA n√£o est√° treinada! Treine o modelo primeiro.', 'error');
                return;
            }

            if (isRealtimeActive) {
                stopRealtime();
            } else {
                await startRealtime();
            }
        }

        async function startRealtime() {
            try {
                logMessage('üöÄ Iniciando an√°lise IA em tempo real...', 'info');
                
                realtimeStream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        width: { ideal: 1280 }, 
                        height: { ideal: 720 }, 
                        facingMode: 'environment' 
                    }
                });
                realtimeVideo.srcObject = realtimeStream;
                
                await new Promise((resolve) => {
                    realtimeVideo.onloadedmetadata = resolve;
                });
                
                isRealtimeActive = true;
                
                document.getElementById('realtimeBtn').textContent = '‚èπÔ∏è PARAR IA TEMPO REAL';
                document.getElementById('realtimeBtn').classList.add('active');
                document.getElementById('realtimeSection').style.display = 'grid';
                
                resetRealtimeStats();
                
                // 3 FPS para an√°lise IA est√°vel
                realtimeInterval = setInterval(() => {
                    performRealtimeDetection();
                }, 333);
                
                startFpsCounter();
                
                logMessage('üî¥ IA TEMPO REAL ATIVA! An√°lise visual cont√≠nua (3 FPS)', 'success');
                updateSystemStatus();
                
            } catch (error) {
                logMessage('‚ùå Erro tempo real: ' + error.message, 'error');
            }
        }

        function stopRealtime() {
            isRealtimeActive = false;
            
            if (realtimeInterval) {
                clearInterval(realtimeInterval);
                realtimeInterval = null;
            }
            
            if (fpsInterval) {
                clearInterval(fpsInterval);
                fpsInterval = null;
            }
            
            if (realtimeStream) {
                realtimeStream.getTracks().forEach(track => track.stop());
                realtimeStream = null;
                realtimeVideo.srcObject = null;
            }
            
            document.getElementById('realtimeBtn').textContent = 'üî¥ INICIAR IA TEMPO REAL';
            document.getElementById('realtimeBtn').classList.remove('active');
            document.getElementById('realtimeSection').style.display = 'none';
            
            logMessage('‚èπÔ∏è IA tempo real parada', 'info');
            updateSystemStatus();
        }

        async function performRealtimeDetection() {
            if (!isRealtimeActive || !model) return;
            
            try {
                realtimeContext.drawImage(realtimeVideo, 0, 0, IMAGE_SIZE, IMAGE_SIZE);
                const imageData = realtimeContext.getImageData(0, 0, IMAGE_SIZE, IMAGE_SIZE);
                
                const tensor = preprocessImageData(imageData);
                const batchedImage = tensor.expandDims(0);
                
                const prediction = model.predict(batchedImage);
                const probabilities = await prediction.data();
                
                const correctProb = probabilities[0];
                const incorrectProb = probabilities[1];
                
                const isCorrect = correctProb > incorrectProb;
                const confidence = Math.max(correctProb, incorrectProb) * 100;
                
                updateRealtimeDisplay(isCorrect, confidence, correctProb, incorrectProb);
                updateRealtimeStats(isCorrect, confidence);
                
                tensor.dispose();
                batchedImage.dispose();
                prediction.dispose();
                
                realtimeStats.frameCount++;
                
            } catch (error) {
                logMessage('‚ùå Erro an√°lise IA: ' + error.message, 'error');
            }
        }

        function updateRealtimeDisplay(isCorrect, confidence, correctProb, incorrectProb) {
            const predictionDiv = document.getElementById('realtimePrediction');
            const confidenceFill = document.getElementById('confidenceFill');
            
            const resultText = isCorrect ? 
                '‚úÖ CERTO (' + (correctProb * 100).toFixed(1) + '%)' : 
                '‚ùå ERRADO (' + (incorrectProb * 100).toFixed(1) + '%)';
            
            const resultClass = isCorrect ? 'prediction-correct-realtime' : 'prediction-incorrect-realtime';
            const confidenceClass = isCorrect ? 'confidence-correct' : 'confidence-incorrect';
            
            predictionDiv.textContent = resultText;
            predictionDiv.className = 'realtime-prediction ' + resultClass;
            
            confidenceFill.style.width = confidence + '%';
            confidenceFill.textContent = confidence.toFixed(1) + '%';
            confidenceFill.className = 'confidence-fill ' + confidenceClass;
        }

        function updateRealtimeStats(isCorrect, confidence) {
            realtimeStats.totalAnalyzed++;
            realtimeStats.confidenceSum += confidence;
            
            if (isCorrect) {
                realtimeStats.correctDetected++;
            } else {
                realtimeStats.incorrectDetected++;
            }
            
            document.getElementById('totalAnalyzed').textContent = realtimeStats.totalAnalyzed;
            document.getElementById('correctDetected').textContent = realtimeStats.correctDetected;
            document.getElementById('incorrectDetected').textContent = realtimeStats.incorrectDetected;
            
            const avgConfidence = realtimeStats.confidenceSum / realtimeStats.totalAnalyzed;
            document.getElementById('avgConfidence').textContent = avgConfidence.toFixed(1) + '%';
        }

        function resetRealtimeStats() {
            realtimeStats = {
                totalAnalyzed: 0,
                correctDetected: 0,
                incorrectDetected: 0,
                confidenceSum: 0,
                frameCount: 0
            };
            
            document.getElementById('totalAnalyzed').textContent = '0';
            document.getElementById('correctDetected').textContent = '0';
            document.getElementById('incorrectDetected').textContent = '0';
            document.getElementById('avgConfidence').textContent = '0%';
            document.getElementById('realtimePrediction').textContent = 'Aguardando an√°lise IA...';
            document.getElementById('realtimePrediction').className = 'realtime-prediction';
            document.getElementById('confidenceFill').style.width = '0%';
            document.getElementById('confidenceFill').textContent = '0%';
        }

        function startFpsCounter() {
            let frameCount = 0;
            let lastTime = performance.now();
            
            fpsInterval = setInterval(() => {
                const currentTime = performance.now();
                const deltaTime = currentTime - lastTime;
                const fps = (frameCount * 1000 / deltaTime).toFixed(1);
                
                document.getElementById('fpsCounter').textContent = 'FPS: ' + fps;
                
                frameCount = 0;
                lastTime = currentTime;
            }, 1000);
            
            const originalPerform = performRealtimeDetection;
            performRealtimeDetection = function() {
                frameCount++;
                return originalPerform.call(this);
            };
        }

        // ==================== SALVAR/CARREGAR ====================
        async function saveModel() {
            if (!model) {
                logMessage('‚ùå Nenhum modelo IA para salvar', 'error');
                return;
            }
            
            try {
                await model.save('localstorage://pcb-defect-cnn-stable');
                logMessage('üíæ IA salva com sucesso!', 'success');
            } catch (error) {
                logMessage('‚ùå Erro ao salvar IA: ' + error.message, 'error');
            }
        }

        async function loadModel() {
            try {
                model = await tf.loadLayersModel('localstorage://pcb-defect-cnn-stable');
                isModelTrained = true;
                
                document.getElementById('saveModelBtn').disabled = false;
                document.getElementById('testCaptureBtn').disabled = false;
                document.getElementById('testFileBtn').disabled = false;
                document.getElementById('realtimeBtn').disabled = false;
                
                updateModelInfo(model);
                
                logMessage('üìÇ IA carregada com sucesso!', 'success');
                logMessage('ÔøΩÔøΩ An√°lise em tempo real dispon√≠vel!', 'info');
                updateSystemStatus();
            } catch (error) {
                logMessage('‚ùå Erro ao carregar IA: ' + error.message, 'error');
            }
        }

        function resetData() {
            if (confirm('ÔøΩÔøΩ Resetar toda a IA e dados?')) {
                if (isRealtimeActive) {
                    stopRealtime();
                }
                
                correctImages.forEach(tensor => tensor.dispose());
                incorrectImages.forEach(tensor => tensor.dispose());
                
                correctImages = [];
                incorrectImages = [];
                
                if (model) {
                    model.dispose();
                    model = null;
                }
                
                isModelTrained = false;
                document.getElementById('trainBtn').disabled = true;
                document.getElementById('saveModelBtn').disabled = true;
                document.getElementById('testCaptureBtn').disabled = true;
                document.getElementById('testFileBtn').disabled = true;
                document.getElementById('realtimeBtn').disabled = true;
                document.getElementById('modelInfo').style.display = 'none';
                
                hideTrainingProgress();
                updateImageCounter();
                updateSystemStatus();
                
                logMessage('üîÑ IA e dados resetados!', 'info');
            }
        }

        // ==================== TESTE MANUAL ====================
        function captureForTest() {
            if (!stream) {
                logMessage('‚ùå C√¢mera n√£o est√° ligada', 'error');
                return;
            }
            
            try {
                captureContext.drawImage(videoElement, 0, 0, IMAGE_SIZE, IMAGE_SIZE);
                const imageData = captureContext.getImageData(0, 0, IMAGE_SIZE, IMAGE_SIZE);
                const tensor = preprocessImageData(imageData);
                
                makePrediction(tensor);
                logMessage('üì∏ Teste IA realizado!', 'success');
            } catch (error) {
                logMessage('‚ùå Erro teste: ' + error.message, 'error');
            }
        }

        function handleTestFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    try {
                        const canvas = document.createElement('canvas');
                        canvas.width = IMAGE_SIZE;
                        canvas.height = IMAGE_SIZE;
                        const ctx = canvas.getContext('2d');
                        
                        ctx.drawImage(img, 0, 0, IMAGE_SIZE, IMAGE_SIZE);
                        const imageData = ctx.getImageData(0, 0, IMAGE_SIZE, IMAGE_SIZE);
                        const tensor = preprocessImageData(imageData);
                        
                        makePrediction(tensor);
                        logMessage('üìÅ Arquivo testado pela IA!', 'success');
                    } catch (error) {
                        logMessage('‚ùå Erro arquivo teste: ' + error.message, 'error');
                    }
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function testWithFile() {
            document.getElementById('testFileInput').click();
        }

        async function makePrediction(imageTensor) {
            if (!model || !isModelTrained) {
                logMessage('‚ùå IA n√£o est√° treinada', 'error');
                return;
            }
            
            try {
                const batchedImage = imageTensor.expandDims(0);
                const prediction = model.predict(batchedImage);
                const probabilities = await prediction.data();
                
                const correctProb = probabilities[0];
                const incorrectProb = probabilities[1];
                
                const isCorrect = correctProb > incorrectProb;
                const confidence = Math.max(correctProb, incorrectProb) * 100;
                
                displayPredictionResult(isCorrect, confidence, correctProb, incorrectProb);
                
                batchedImage.dispose();
                prediction.dispose();
                imageTensor.dispose();
                
            } catch (error) {
                logMessage('‚ùå Erro previs√£o IA: ' + error.message, 'error');
            }
        }

        function displayPredictionResult(isCorrect, confidence, correctProb, incorrectProb) {
            const resultDiv = document.getElementById('predictionResult');
            
            const resultText = isCorrect ? 
                '‚úÖ AN√ÅLISE IA: CERTO - ' + confidence.toFixed(1) + '% confian√ßa (Correto: ' + (correctProb * 100).toFixed(1) + '% | Incorreto: ' + (incorrectProb * 100).toFixed(1) + '%)' :
                '‚ùå AN√ÅLISE IA: ERRADO - ' + confidence.toFixed(1) + '% confian√ßa (Correto: ' + (correctProb * 100).toFixed(1) + '% | Incorreto: ' + (incorrectProb * 100).toFixed(1) + '%)';
            
            const resultClass = isCorrect ? 'prediction-correct' : 'prediction-incorrect';
            
            resultDiv.innerHTML = '<div class="prediction-result ' + resultClass + '">' + resultText + '</div>';
            
            logMessage('üß† IA: ' + resultText, isCorrect ? 'success' : 'warning');
        }

        // ==================== UTILIDADES ====================
        function logMessage(message, type) {
            type = type || 'info';
            const logArea = document.getElementById('logArea');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry log-' + type;
            logEntry.textContent = '[' + timestamp + '] ' + message;
            
            logArea.appendChild(logEntry);
            logArea.scrollTop = logArea.scrollHeight;
            
            if (logArea.children.length > 150) {
                logArea.removeChild(logArea.firstChild);
            }
        }

        function showErrorBox(message) {
            const errorBox = document.createElement('div');
            errorBox.className = 'error-box';
            errorBox.innerHTML = '<strong>‚ö†Ô∏è Erro IA:</strong> ' + message;
            
            const mainContent = document.querySelector('.main-content');
            mainContent.insertBefore(errorBox, mainContent.firstChild);
            
            setTimeout(() => {
                if (errorBox.parentNode) {
                    errorBox.parentNode.removeChild(errorBox);
                }
            }, 8000);
        }

        // ==================== LIMPEZA ====================
        window.addEventListener('beforeunload', function() {
            if (isRealtimeActive) {
                stopRealtime();
            }
            
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
            
            correctImages.forEach(tensor => tensor.dispose());
            incorrectImages.forEach(tensor => tensor.dispose());
            
            if (model) {
                model.dispose();
            }
        });

        window.addEventListener('error', function(event) {
            logMessage('‚ùå Erro global IA: ' + event.error.message, 'error');
            console.error('Erro IA capturado:', event.error);
        });

        window.addEventListener('unhandledrejection', function(event) {
            logMessage('‚ùå Promise IA rejeitada: ' + event.reason, 'error');
            console.error('Promise IA rejeitada:', event.reason);
        });
    </script>
</body>
</html>