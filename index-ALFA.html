<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Detector Avan√ßado de Defeitos</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@2.0.4/dist/mobilenet.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/knn-classifier@1.2.2/dist/knn-classifier.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/opencv.js@1.2.1/opencv.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 100%;
            margin: 0;
            padding: 10px;
            text-align: center;
            background-color: #121212;
            color: white;
        }
        h1 {
            color: #4CAF50;
            margin-bottom: 15px;
            font-size: 1.5rem;
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .camera-container {
            position: relative;
            width: 100%;
            max-width: 640px;
            height: auto;
            aspect-ratio: 4/3;
            margin: 0 auto 15px;
            border: 2px solid #333;
            background-color: #000;
            border-radius: 8px;
            overflow: hidden;
        }
        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        .controls {
            margin: 15px 0;
            display: flex;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
        }
        button {
            padding: 10px 15px;
            font-size: 14px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #333;
            color: white;
            transition: all 0.3s;
            min-width: 140px;
        }
        button:hover {
            background-color: #444;
        }
        button#add-correct {
            background-color: #2E7D32;
        }
        button#add-defective {
            background-color: #C62828;
        }
        button#train {
            background-color: #1565C0;
        }
        button#reset {
            background-color: #EF6C00;
        }
        button.active {
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
        }
        #status {
            margin: 15px 0;
            padding: 10px;
            background-color: #333;
            border-radius: 5px;
            min-height: 20px;
            font-size: 14px;
        }
        .confidence-meter {
            width: 100%;
            max-width: 300px;
            height: 10px;
            background-color: #333;
            border-radius: 5px;
            margin: 10px auto;
            overflow: hidden;
        }
        #confidence-bar {
            height: 100%;
            width: 0%;
            background-color: #4CAF50;
            transition: width 0.3s;
        }
        .led-indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: #333;
            margin: 10px auto;
            transition: background-color 0.3s;
        }
        .led-indicator.active {
            background-color: #4CAF50;
            box-shadow: 0 0 10px #4CAF50;
        }
        .thumbnail-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
            margin-top: 15px;
        }
        .thumbnail {
            width: 80px;
            height: 60px;
            object-fit: cover;
            border: 2px solid #333;
            border-radius: 4px;
        }
        .thumbnail.correct {
            border-color: #4CAF50;
        }
        .thumbnail.defective {
            border-color: #F44336;
        }
        .detection-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            padding: 8px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 5px;
            font-size: 14px;
            text-align: left;
        }
        .mobile-controls {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Detector Avan√ßado de Placas Eletr√¥nicas</h1>
        
        <div class="camera-container">
            <video id="webcam" autoplay playsinline muted></video>
            <canvas id="canvas"></canvas>
            <div class="detection-overlay" id="detection-info">
                Aguardando detec√ß√£o...
            </div>
        </div>
        
        <div class="mobile-controls">
            <button id="toggle-camera">üîÑ C√¢mera</button>
            <button id="toggle-flash">‚ö° LED</button>
        </div>
        
        <div class="led-indicator" id="led"></div>
        <div class="confidence-meter"><div id="confidence-bar"></div></div>
        
        <div class="controls">
            <button id="add-correct">Adicionar Correta</button>
            <button id="add-defective">Adicionar Defeituosa</button>
            <button id="train">Treinar Modelo</button>
            <button id="reset">Resetar</button>
        </div>
        
        <div id="status">Inicializando sistema...</div>
        
        <h3>Imagens de Treino</h3>
        <div class="thumbnail-container" id="thumbnails"></div>
    </div>

    <script>
        // Elementos da interface
        const webcam = document.getElementById('webcam');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const detectionInfo = document.getElementById('detection-info');
        const statusElement = document.getElementById('status');
        const thumbnailsContainer = document.getElementById('thumbnails');
        const confidenceBar = document.getElementById('confidence-bar');
        const ledIndicator = document.getElementById('led');
        
        // Vari√°veis do sistema
        let net;
        let classifier;
        let isPredicting = false;
        let currentStream = null;
        let facingMode = "environment";
        let flashOn = false;
        let track = null;
        let speechSynth = window.speechSynthesis;
        let cvReady = false;
        let consecutiveMatches = 0;
        let lastDetection = null;
        let detectionThreshold = 3;
        let isBoardDetected = false;
        let boardContour = null;
        
        // Configura√ß√µes
        const captureSize = { width: 224, height: 224 };
        const minContourArea = 10000; // √Årea m√≠nima para considerar uma placa
        
        // Inicializar o sistema
        async function init() {
            try {
                // Carregar modelos
                statusElement.textContent = 'Carregando modelos...';
                [net, classifier] = await Promise.all([
                    mobilenet.load(),
                    knnClassifier.create()
                ]);
                
                // Configurar OpenCV
                await loadOpenCV();
                
                // Iniciar c√¢mera
                await startCamera();
                
                // Configurar canvas
                canvas.width = webcam.videoWidth;
                canvas.height = webcam.videoHeight;
                
                // Iniciar loop de processamento
                requestAnimationFrame(processFrame);
                
            } catch (error) {
                statusElement.textContent = `Erro: ${error.message}`;
                console.error(error);
            }
        }
        
        // Carregar OpenCV
        function loadOpenCV() {
            return new Promise((resolve) => {
                if (window.cv) {
                    cvReady = true;
                    resolve();
                    return;
                }
                
                const script = document.createElement('script');
                script.src = 'https://docs.opencv.org/4.5.5/opencv.js';
                script.onload = () => {
                    cv['onRuntimeInitialized'] = () => {
                        cvReady = true;
                        resolve();
                    };
                };
                document.body.appendChild(script);
            });
        }
        
        // Iniciar c√¢mera
        async function startCamera() {
            statusElement.textContent = 'Iniciando c√¢mera...';
            
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }
            
            const constraints = {
                video: {
                    facingMode: facingMode,
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                },
                audio: false
            };
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                currentStream = stream;
                webcam.srcObject = stream;
                track = stream.getVideoTracks()[0];
                
                await new Promise((resolve) => {
                    webcam.onloadedmetadata = () => {
                        canvas.width = webcam.videoWidth;
                        canvas.height = webcam.videoHeight;
                        resolve();
                    };
                });
                
                statusElement.textContent = 'Pronto para capturar imagens!';
                return true;
            } catch (error) {
                statusElement.textContent = `Erro na c√¢mera: ${error.message}`;
                console.error(error);
                return false;
            }
        }
        
        // Processar cada frame
        async function processFrame() {
            if (!cvReady || webcam.readyState !== HTMLMediaElement.HAVE_ENOUGH_DATA) {
                requestAnimationFrame(processFrame);
                return;
            }
            
            // Desenhar o frame no canvas
            ctx.drawImage(webcam, 0, 0, canvas.width, canvas.height);
            
            // Detectar placa eletr√¥nica (retangular)
            detectBoard();
            
            // Se estiver prevendo e uma placa foi detectada
            if (isPredicting && isBoardDetected) {
                await predict();
            }
            
            requestAnimationFrame(processFrame);
        }
        
        // Detectar placa eletr√¥nica
        function detectBoard() {
            if (!cvReady) return;
            
            try {
                // Converter imagem para OpenCV
                const src = cv.imread(canvas);
                const dst = new cv.Mat();
                const contours = new cv.MatVector();
                const hierarchy = new cv.Mat();
                
                // Pr√©-processamento
                cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY);
                cv.threshold(dst, dst, 120, 255, cv.THRESH_BINARY_INV);
                cv.findContours(dst, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
                
                // Encontrar maior contorno retangular
                let maxArea = 0;
                boardContour = null;
                
                for (let i = 0; i < contours.size(); ++i) {
                    const contour = contours.get(i);
                    const perimeter = cv.arcLength(contour, true);
                    const approx = new cv.Mat();
                    cv.approxPolyDP(contour, approx, 0.02 * perimeter, true);
                    
                    // Verificar se √© um ret√¢ngulo (4 lados)
                    if (approx.rows === 4) {
                        const area = cv.contourArea(approx);
                        if (area > minContourArea && area > maxArea) {
                            maxArea = area;
                            boardContour = approx;
                        }
                    }
                    approx.delete();
                }
                
                // Desenhar contorno se encontrado
                if (boardContour) {
                    isBoardDetected = true;
                    const color = new cv.Scalar(0, 255, 0, 255);
                    cv.drawContours(src, new cv.MatVector(boardContour), -1, color, 3);
                    
                    // Calcular ret√¢ngulo delimitador
                    const rect = cv.boundingRect(boardContour);
                    detectionInfo.textContent = `Placa detectada: ${rect.width}x${rect.height}px`;
                } else {
                    isBoardDetected = false;
                    detectionInfo.textContent = 'Nenhuma placa detectada';
                }
                
                // Liberar mem√≥ria
                cv.imshow(canvas, src);
                src.delete();
                dst.delete();
                contours.delete();
                hierarchy.delete();
                
            } catch (error) {
                console.error('Erro no OpenCV:', error);
            }
        }
        
        // Obter regi√£o da placa para an√°lise
        function getBoardRegion() {
            if (!boardContour) return null;
            
            const rect = cv.boundingRect(boardContour);
            const x = Math.max(0, rect.x);
            const y = Math.max(0, rect.y);
            const width = Math.min(rect.width, canvas.width - x);
            const height = Math.min(rect.height, canvas.height - y);
            
            // Criar canvas tempor√°rio para extrair a regi√£o
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Extrair a regi√£o da placa
            tempCtx.drawImage(
                canvas, 
                x, y, width, height, 
                0, 0, width, height
            );
            
            return tempCanvas;
        }
        
        // Adicionar exemplo de treino
        async function addExample(classId) {
            if (!isBoardDetected) {
                statusElement.textContent = 'Nenhuma placa detectada para capturar';
                return;
            }
            
            statusElement.textContent = `Capturando imagem ${classId}...`;
            
            // Extrair regi√£o da placa
            const boardCanvas = getBoardRegion();
            if (!boardCanvas) return;
            
            // Processar imagem
            const img = tf.browser.fromPixels(boardCanvas);
            const processedImg = tf.image.resizeBilinear(img, [captureSize.width, captureSize.height]);
            const activation = net.infer(processedImg, 'conv_preds');
            
            // Adicionar ao classificador
            classifier.addExample(activation, classId);
            
            // Criar miniatura
            createThumbnail(img, classId);
            
            // Limpar mem√≥ria
            img.dispose();
            processedImg.dispose();
            activation.dispose();
            
            statusElement.textContent = `Imagem ${classId} adicionada. Total: ${classifier.getNumExamples()}`;
        }
        
        // Criar miniatura
        function createThumbnail(imgTensor, classId) {
            const canvas = document.createElement('canvas');
            canvas.width = captureSize.width;
            canvas.height = captureSize.height;
            tf.browser.toPixels(imgTensor, canvas).then(() => {
                const thumbnail = document.createElement('img');
                thumbnail.src = canvas.toDataURL();
                thumbnail.classList.add('thumbnail', classId);
                thumbnailsContainer.appendChild(thumbnail);
            });
        }
        
        // Treinar modelo
        async function train() {
            if (classifier.getNumExamples() === 0) {
                statusElement.textContent = 'Adicione imagens antes de treinar';
                return;
            }
            
            statusElement.textContent = 'Preparando modelo...';
            isPredicting = true;
            consecutiveMatches = 0;
            lastDetection = null;
            statusElement.textContent = 'Modelo pronto! Analisando...';
        }
        
        // Fazer predi√ß√£o
        async function predict() {
            if (!isPredicting || !isBoardDetected) return;
            
            // Extrair regi√£o da placa
            const boardCanvas = getBoardRegion();
            if (!boardCanvas) return;
            
            // Processar imagem
            const img = tf.browser.fromPixels(boardCanvas);
            const processedImg = tf.image.resizeBilinear(img, [captureSize.width, captureSize.height]);
            const activation = net.infer(processedImg, 'conv_preds');
            
            const result = await classifier.predictClass(activation);
            const confidence = result.confidences[result.label];
            
            // Atualizar barra de confian√ßa
            confidenceBar.style.width = `${Math.round(confidence * 100)}%`;
            confidenceBar.style.backgroundColor = result.label === 'correta' ? '#4CAF50' : '#F44336';
            
            // Verificar se a detec√ß√£o √© consistente
            if (lastDetection === result.label) {
                consecutiveMatches++;
            } else {
                consecutiveMatches = 1;
                lastDetection = result.label;
            }
            
            // S√≥ aceitar ap√≥s 3 detec√ß√µes consistentes
            if (consecutiveMatches >= detectionThreshold) {
                if (result.label === 'correta') {
                    // Feedback visual positivo
                    ledIndicator.classList.add('active');
                    setTimeout(() => ledIndicator.classList.remove('active'), 300);
                    detectionInfo.textContent = 'Placa CORRETA detectada';
                } else {
                    // Feedback de voz e visual para defeito
                    detectionInfo.textContent = 'DEFEITO detectado na placa!';
                    speak('Placa errada');
                }
            } else {
                detectionInfo.textContent = `Analisando... (${consecutiveMatches}/${detectionThreshold})`;
            }
            
            // Liberar mem√≥ria
            img.dispose();
            processedImg.dispose();
            activation.dispose();
        }
        
        // Sintetizar voz
        function speak(text) {
            if (speechSynth.speaking) speechSynth.cancel();
            
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = 0.9;
            utterance.pitch = 0.8;
            speechSynth.speak(utterance);
        }
        
        // Alternar c√¢mera
        async function toggleCamera() {
            facingMode = facingMode === "user" ? "environment" : "user";
            statusElement.textContent = `Alternando para c√¢mera ${facingMode === "user" ? "frontal" : "traseira"}...`;
            const success = await startCamera();
            if (success) {
                statusElement.textContent = `C√¢mera ${facingMode === "user" ? "frontal" : "traseira"} ativada!`;
            }
        }
        
        // Alternar flash
        async function toggleFlash() {
            if (!track || !track.getCapabilities().torch) {
                statusElement.textContent = 'Flash n√£o dispon√≠vel neste dispositivo';
                return;
            }
            
            try {
                flashOn = !flashOn;
                await track.applyConstraints({
                    advanced: [{ torch: flashOn }]
                });
                statusElement.textContent = `Flash ${flashOn ? 'ligado' : 'desligado'}`;
            } catch (error) {
                statusElement.textContent = 'Erro ao controlar flash';
                console.error(error);
            }
        }
        
        // Resetar sistema
        function reset() {
            isPredicting = false;
            classifier.clearAllClasses();
            thumbnailsContainer.innerHTML = '';
            confidenceBar.style.width = '0%';
            ledIndicator.classList.remove('active');
            detectionInfo.textContent = 'Aguardando detec√ß√£o...';
            statusElement.textContent = 'Sistema resetado. Pronto para novas imagens.';
            consecutiveMatches = 0;
            lastDetection = null;
        }
        
        // Event listeners
        document.getElementById('add-correct').addEventListener('click', () => addExample('correta'));
        document.getElementById('add-defective').addEventListener('click', () => addExample('defeituosa'));
        document.getElementById('train').addEventListener('click', train);
        document.getElementById('reset').addEventListener('click', reset);
        document.getElementById('toggle-camera').addEventListener('click', toggleCamera);
        document.getElementById('toggle-flash').addEventListener('click', toggleFlash);
        
        // Iniciar sistema
        init();
    </script>
</body>
</html>